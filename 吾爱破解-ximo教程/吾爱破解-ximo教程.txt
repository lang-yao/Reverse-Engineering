1.手脱UPX壳 
调试工具:PEID和ollyice(OD入口点不对)
脱壳机-脱upx壳
跳转:
　　1. f4
　　2. 打断点
OEP (入口点): 大跨度跳转
3种脱壳方式
　　1.OD插件，LordPE(需要用importCRE修复)
　　2.OD dump方式一
　　3.OD dump方式二
UPX壳脱壳方法：
方法1：单步跟踪
	入口点不一样，OD版本不同，吾爱破解的OD入口点设置有问题，切换Main也不行
	程序领空 基址00400000，偏移xxx
	系统领空 7xxxxxxx 
方法2：ESP定律法
	关键句的下一句，ESP突变，ESP数据窗口跟踪
	打硬件断点，word/dword(硬件断点及时删)
命令：
　　1.dd XXXXX
　　2.hr XXXXX
方法3：2次内存镜像法
	Delphi程序的地址段特征
	M:内存(alt+m)，区别系统领空
	.rsrc	资源文件
	下断点f2	运行
	UPX0	下断点 运行
方法4：一步直达法
	适用范围：大部分UPX壳和ASPACK壳
	搜索命令,pop,push
2. 手脱ASPACK壳
ASPack 2.12 -> Alexey Solodovnikov
调试工具：PEID和ollyice(OD和教程不对)

6种方法脱
方法1：单步跟踪
	跑飞了
	f7进入call
	popad离oep近了
方法2：ESP定律
方法3：一步直达
方法4：2次内存镜像
	程序段的.rsrc 下断点
	.text 下断点
方法5：模拟跟踪
	内存找SFX,imports,relocations
	命令：
	tc eip<地址
	没有直接找到OEP，跟踪到了系统领空，通过“执行到返回(alt+f9)”/“执行到用户代码(ctrl+f9)”到用户代码
	断续单步跟踪
方法6：SFX模拟跟踪
	菜单栏-选项-调试-SFX
	块方式跟踪
3. 基础脱壳教程3：手脱NSPACK（北斗）
壳：
nSPack 1.3 -> North Star/Liu Xing Ping
NsPacK V3.7 -> LiuXingPing *
方法1：单步跟踪
	离程序形如比较近的call，F7进入
	使用lordPE脱壳
	使用importREC修复
方法2：ESP定律
方法3：SFX模拟跟踪
	找SFX,数据，输入表，资源处跟踪
方法4：2次内存镜像
	PE是从上到下解压的，先解压资源文件，然后解压代码段，
	没有资源文件，直接code段下断点
	Q:如果有资源文件，为什么不直接在代码段下断点？
北斗，直接搜：
at GetVersion
在retn下断点单步(吾爱版OD直接到系统领空然后运行到用户代码直接跑飞，，Ollyice单步后直接到OEP)
适用于北斗3.0以前的壳
北斗2.4加壳
EP区段是nsp0，是nspack,北斗的壳
单步进入jump,ESP定律法搞定
北斗3.7壳
ESP定律法搞定
4.基础脱壳教程4：手脱FSG壳
脱FSG 2.0 -> bart/xt

单步跟踪找OEP
OEP地址一般存在寄存器里面，不直接给出
手动、查找IAT：工具importREC
找任意一个call，在importantREC中定位call的地址
00425000  77DA6C17  advapi32.RegCloseKey
00425280  7C838E18  kernel32.LCMapStringA

RVA=25000
SIZE=280
SIZE=1000（懒省事，有垃圾指针）

方法1：单步跟踪
方法2：ESP定律
方法3：特殊ESP定律
只适用于FSG 2.0 -> bart/xt
00400154 >  8725 04A24700   xchg dword ptr ds:[0x47A204],esp         ; qqspirit.0047A208
0040015A    61              popad
0040015B    94              xchg eax,esp                             ; qqspirit.0047A208
跳到这在堆栈窗口第四行为OEP地址，在反汇编窗口跟随，下硬件断点，直接跳到OEP

5.基础脱壳教程5：手脱PECompact2.X的壳
1。单步
进入系统领空后继续跟踪
OD载入脱壳后的程序直接到OEP
VC6:OEP
0040A86D >  55              push    ebp

2。ESP定律
第一个ESP突变不对，跟踪后进入系统领空
第二个成功
3。BP VirtualFree
F9运行后
F2取消断点
ALT+F9回到用户代码
查找 push 8000(特征码)
F4运行到这
然后单步跟到OEP
4。BP VirtualFree
两次F9运行
中断后取消断点，Alt+F9返回
单步走到OEP
5.0040A86D >  B8 74DE4500     mov eax,qqspirit.0045DE74
上来就是MOV命令，参数后面跟0045de74这种
运行命令：
bp 0045de74

045DE74    B8 F9CB45F0     mov eax,F045CBF9

0045DE79    8D88 9E120010   lea ecx,dword ptr ds:[eax+1000129E]
0045DE7F    8941 01         mov dword ptr ds:[ecx+1],eax
0045DE82    8B5424 04       mov edx,dword ptr ss:[esp+4]
0045DE86    8B52 0C         mov edx,dword ptr ds:[edx+C]
0045DE89    C602 E9         mov byte ptr ds:[edx],0E9
0045DE8C    83C2 05         add edx,5
0045DE8F    2BCA            sub ecx,edx
0045DE91    894A FC         mov dword ptr ds:[edx-4],ecx
0045DE94    33C0            xor eax,eax
0045DE96    C3              retn
0045DE97    B8 78563412     mov eax,12345678//下断
Q:F4!=断点F2+F9？
F4跑飞，F2+F9不会
6。bp VirtualAlloc  SHIFT+F9运行
取消断点
ALT+F9
向下拉，看到JMP。运行到这

7.最后一次异常法；
取消所有异常。
2次跑飞。
在堆栈窗口找SE句柄
crtl+g转到:SE xxxx处

8。两次内存
9。at GetVersion
C++程序的程序的方法，OEP最终在上面

6.基础脱壳教程6：手脱EZIP 壳
开始遇到jmp直接F8
1。单步
脱壳后无法运行，可能入口点找错了。以用重建PE的方法。
2。ESP定律

7.基础脱壳教程7：手脱tElock 0.98b1壳

1。最后一次异常法
Ctrl+F9 运行至ret
Alt+F9 运行至上层调用的下句
Shift+F9 忽略异常运行
f4!=f2+f9

取消所有异常。
n次跑飞。
运行n-1次在堆栈窗口找SE句柄
crtl+g转到:SE xxxx处
1.7汉化不能修复
https://www.52pojie.cn/thread-618899-1-1.html
解决方法：需要用ImportREC_fix.exe 1.6版本
先打开原程序，然后再打开ire等级3跟踪修复，后打开原程序不能跟踪
剩余5个剪切掉OK，修复完毕！

2.模拟跟踪
使用前提，程序没有SEH安装
跳过16次异常后，没有SEH安装，可以使用模拟跟踪
16次之后，在堆栈窗口找SE句柄
crtl+g转到:SE 0042D7FD处
下断点，运行到这，然后直接模板跟踪到OEP

3。两次内存镜像
调试设置-》异常勾选
shift+f9运行
第一次断点在程序段的.rsrc
第二次在.text代码段

8.基础脱壳教程8：手脱exe32pack壳

1。ESP定律
入栈是重要语句
重要语句可以用ESP定律法
Q：为什么OD会自动跑？我都到OEP了，还没脱壳就跑到下面代码了
用ODdump插件脱壳有问题，需要使用lordPE+importCre脱壳
lord+impCRE脱壳OK，lordPE脱壳后，壳没有脱干净，peid查壳后，发现仍然有壳，不能运行
ollyICE原版脱壳失败
OD吾爱版脱壳成功

2。下断：BP IsDebuggerPresent 
运行，取消断点
ALT+F9,
计算ss+edi
转到OEP！

9.基础脱壳教程9：脱WinUpack加的壳

加条件断点的方法。

加壳后，什么也没发现，可以看.ep区段：.Upack
汇编：test eax,eax
循环，加载输入表后，跳转OEP
也可以长久单步跟踪

10.基础脱壳教程10：脱壳的基本思路及小结

自己加壳自己脱的学习思路
脱壳熟练后，可以用插件和脱壳机节省时间。

壳的分类：压缩壳、加密壳
lordPE，加密壳必须修复，压缩壳不需要修复
importCRE剪切指针后，不能运行尝试修复。
脱壳的基本方法：
1。单步
FSG1.33脱壳
条件断点，寄存器用[]，[esi]==0
2。ESP定律
pushad 关键名下一行
吾爱版本失败，ollyice可以成功脱壳

3。内存镜像
4。模拟跟踪（2类）
1）SFX跟踪
2）tc eip<XXXX
5。最后一次异常
忽略内核异常
重建PE是在脱壳修复之后如果还不能运行
6。特殊
直接搜索popad:PE Pack 1.0 -> ANAKiN


常见语言的入口点：
VB：
004012D4 >  68 54474000     push QQ个性网.00404754
004012D9    E8 F0FFFFFF     call <jmp.&MSVBVM60.#100>
004012DE    0000            add byte ptr ds:[eax],al
004012E0    0000            add byte ptr ds:[eax],al
004012E2    0000            add byte ptr ds:[eax],al
004012E4    3000            xor byte ptr ds:[eax],al
004012E6    0000            add byte ptr ds:[eax],al
004012E8    48              dec eax
delphi:
004A5C54 >  55              push ebp
004A5C55    8BEC            mov ebp,esp
004A5C57    83C4 F0         add esp,-10
004A5C5A    B8 EC594A00     mov eax,openpro.004A59EC
BC++:
00401678 > /EB 10           jmp short btengine.0040168A
0040167A   |66:623A         bound di,dword ptr ds:[edx]
0040167D   |43              inc ebx
0040167E   |2B2B            sub ebp,dword ptr ds:[ebx]
00401680   |48              dec eax
00401681   |4F              dec edi
00401682   |4F              dec edi
00401683   |4B              dec ebx
00401684   |90              nop
00401685  -|E9 98005400     jmp 00941722
0040168A   \A1 8B005400     mov eax,dword ptr ds:[54008B]
0040168F    C1E0 02         shl eax,2
00401692    A3 8F005400     mov dword ptr ds:[54008F],eax
00401697    52              push edx
00401698    6A 00           push 0
0040169A    E8 99D01300     call <jmp.&KERNEL32.GetModuleHandleA>
0040169F    8BD0            mov edx,eax
VC++:
0040A41E >  55              push ebp
0040A41F    8BEC            mov ebp,esp
0040A421    6A FF           push -1
0040A423    68 C8CB4000     push 跑跑排行.0040CBC8
0040A428    68 A4A54000     push <jmp.&MSVCRT._except_handler3>
0040A42D    64:A1 00000000  mov eax,dword ptr fs:[0]
0040A433    50              push eax
0040A434    64:8925 0000000>mov dword ptr fs:[0],esp
0040A43B    83EC 68         sub esp,68
0040A43E    53              push ebx
0040A43F    56              push esi
0040A440    57              push edi
MASM(汇编):
004035C9 >  6A 00           push 0
004035CB    E8 A20A0000     call <jmp.&kernel32.GetModuleHandleA>
004035D0    A3 5B704000     mov dword ptr ds:[40705B],eax
004035D5    68 80000000     push 80
004035DA    68 2C754000     push 11.0040752C
004035DF    FF35 5B704000   push dword ptr ds:[40705B]
004035E5    E8 820A0000     call <jmp.&kernel32.GetModuleFileNameA>
004035EA    E8 87070000     call 11.00403D76
004035EF    6A 00           push 0
004035F1    68 0B364000     push 11.0040360B
004035F6    6A 00           push 0
004035F8    6A 64           push 64
004035FA    FF35 5B704000   push dword ptr ds:[40705B]
11.基础脱壳教程11：附加数据的处理方法
nSPack 1.3 壳，overlay带附加数据的程序
nSPack 1.3 -> North Star/Liu Xing Ping [Overlay]
特殊方法脱壳，直接搜索命令popad
脱壳后用工具进行附加数据
工具：overlay最终版（杀软可能报毒）
       WIN HEX或HEX WORKSHOP
复制全为0后面的数据到脱壳后的程序
计算的方法：lordPe查看区段，实际大小和虚拟大小和偏移量
实际大小+实际偏移量：8800+400=8c00
十六进制，转到8c00
最后空数据不能覆盖

12.基础脱壳教程12：自校验的去除方法

ASPack 2.12 -> Alexey Solodovnikov
ESP定律法脱壳
lordPE+IR修复
IR修复：输入表只有一个函数，一般不可能，需要手动查找IAT修复
找cmp,执行命令dd xxxx,找RVA
修复后可以运行。

去除自校验：
对比脱壳后的程序，两个程序都下断点
bp CreateFileA
跟踪比较程序跳转差异

对异常跳转改为nop或je，分析跳转条件
修改后保存

13.基础脱壳教程13：脱壳的简单应用——软件的汉化及DIY

1. 先查壳
2。有壳就脱壳
3。对软件进行破解、汉化、美化等DIY
工具：
资源编辑：
resource hacker
peexplorer
getvbres ............VB类的汉化、DIY
xnresource 可以自己加功能
等等
BC++，delphi在resouce hacker中特有的RCData。用peexplorern修改。
ASPack 2.12 -> Alexey Solodovnikov
ESP定律法脱壳
getvbres修改资源失败，可能0.9版本太老
FSG 2.0 -> bart/xt
SFX跟踪法脱壳
使用FixRes.exe脱壳后修复
resource hacker修改资源
Borland C++ 1999：btengine.exe
修改资源失败
可能xnresource版本过旧

14.基础脱壳教程14：手脱ASPACK的变形壳

peid什么也没发现可以看EP区段（不一定准确，可以改）
call命令近的F7，远的F8

变形壳程序的脱壳思路：
yoda's Protector v1.02 (.dll,.ocx) 
类似最后一次异常法，在循环中，不断执行，最终跑飞前的一次，跳转到程序正常执行的位置。
SFX跟踪脱壳

15.基础脱壳教程15：ASPACK变形壳(续)及学会用脚本进行脱壳
用插件脚本脱壳，不一定准确，变形壳可能出现问题
自动运行到OEP

16.基础脱壳教程16：脱ACProtect132(无Stolen Code)

ACprotect壳：ep区段：.perplex

调试-异常：去掉：内存访问异常的勾选
1。设置异常，隐藏OD（高版本ACprotect壳检验OD）
最后一次异常法，(出现int 3的位置)
堆栈窗口找SE句柄
2。SE处，数据窗口跟随，下内存访问断点（一般断点可能不能用）
3。SHIFT+F9，F2，再一次SHIFT+F9，下断，再一次SHIFT+F9
4，取消所有断点（alt+b,断点窗口，清除内存访问断点，跳转到retn处）
5，内存，00401000代码段。F2，SHIFT+F9
6，直达OEP！！
7。修复，脱壳成功
VB的程序：
--------------------------------------------------------
004012D4    68 54474000     push    00404754
004012D9    E8 F0FFFFFF     call    004012CE                         ; jmp 到 msvbvm60.ThunRTMain
004012DE    0000            add     byte ptr [eax], al
004012E0    0000            add     byte ptr [eax], al
004012E2    0000            add     byte ptr [eax], al
004012E4    3000            xor     byte ptr [eax], al
004012E6    0000            add     byte ptr [eax], al
004012E8    48              dec     eax
004012E9    0000            add     byte ptr [eax], al
004012EB    0000            add     byte ptr [eax], al
004012ED    0000            add     byte ptr [eax], al
004012EF    0068 36         add     byte ptr [eax+36], ch

17.基础脱壳教程17：脱ACProtect(存在Stolen Code)
UltraProtect 1.x是ACprotect以前的名字
UltraProtect 1.x -> RISCO Software Inc.
常规方法，直达OEP，同上

设置跟踪条件，ctrl+f11，跟踪步入

二进制复制被偷取的代码

.text 代码段下断点
修复被偷取的代码
新建EIP到修复后的OEP
ODdump不重建输入表？？？
修复：
等级3跟踪，有插件可以用插件跟踪
修复，成功脱掉！

004254C9    55              push ebp
004254CA    8BEC            mov ebp,esp
004254CC    83EC 44         sub esp,44

