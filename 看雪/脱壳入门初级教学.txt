脱壳入门初级教学
学习的地址：https://bbs.pediy.com/thread-20366.htm
第一课 PE格式
PE格式，PE是Portable Executable File Format（可移植的执行体）简写，它是目前Windows平台上的主流可执行文件格式。

第二课 SEH技术
结构化异常处理（Structured Exception Handling，SEH）是Windows操作系统处理程序错误或异常的技术。SEH是Windows操作系统的一种系统机制，与特定的程序设计语言无关。
第三课 认识壳
1. 什么是壳？
在一些计算机软件里也有一段专门负责
 保护软件不被非法修改或反编译的程序  
。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，就把这样的程序称为“壳”了。
 壳和病毒在某些方面比较类似，都需要比原程序代码更早的获得控制权。壳修改了原程序的执行文件的组织结构，从而能够比原程序的代码提前获得控制权，并且不会影响原程序的正常运行。
 加壳过的EXE文件是可执行文件，它可以同正常的EXE文件一样执行。用户执行的实际上是外壳程序，这个外壳程序负责把用户原来的程序在内存中解压缩，并把控制权交还给解开后的真正程序，这一切工作都是在内存中运行的，整个过程对用户是透明的。
 1）获取壳自己所需要使用的API地址
   如果用PE编辑工具查看加壳后的文件，会发现未加壳的文件和加壳后的文件的输入表不一样，加壳后的输入表一般所引入的DLL和API函数很少，甚至只有Kernel32.dll以及GetProcAddress这个API函数。壳实际上还需要其他的API函数来完成它的工作，为了隐藏这些API，它一般只在壳的代码中用显式链接方式动态加载这些API函数:3个脱壳相关的重要函数介绍
 2）解密原程序的各个区块(Section)的数据
   壳出于保护原程序代码和数据的目的，一般都会加密原程序文件的各个区块。在程序执行时外壳将会对这些区块数据解密，以让程序能正常运行。 壳一般按区块加密的，那么在解密时也按区块解密，并且把解密的区块数据按照区块的定义放在合适的内存位置。
   如果加壳时用到了压缩技术，那么在解密之前还有一道工序，当然是解压缩。这也是一些壳的特色之一，比如说原来的程序文件未加壳时1～2M大小，加壳后反而只有几百K。
   3）重定位
   文件执行时将被映像到指定内存地址中，这个初始内存地址称为基地址（ImageBase）
     对于EXE的程序文件来说，Windows系统会尽量满足。例如某EXE文件的基地址为0x400000，而运行时Windows系统提供给程序的基地址也同样是0x400000。在这种情况下就不需要进行地址“重定位”了。由于不需要对EXE文件进行“重定位”，所以加壳软件把原程序文件中用于保存重定位信息的区块干脆也删除了，这样使得加壳后的文件更加小巧。有些工具提供“Wipe Reloc”的功能，其实就是这个作用。
      不过对于DLL的动态链接库文件来说，Windows系统没有办法保证每一次DLL运行时提供相同的基地址。这样“重定位”就很重要了，此时壳中也需要提供进行“重定位”的代码，否则原程序中的代码是无法正常运行起来的。从这点来说，加壳的DLL比加壳的EXE更难修正。
 4）HOOK-API
 程序文件中的输入表的作用是让Windows系统在程序运行时提供API的实际地址给程序使用。在程序的第一行代码执行之前，Windows系统就完成了这个工作。
   壳一般都修改了原程序文件的输入表，然后自己模仿Windows系统的工作来填充输入表中相关的数据。在填充过程中，外壳就可填充HOOK-API的代码的地址，这样就可间接地获得程序的控制权。
5）跳转到程序原入口点（OEP）
    从这个时候起壳就把控制权交还给原程序了，一般的壳在这里会有明显的一个“分界线”。
3. 压缩引擎   
    各类加壳软件，其压缩算法一般不是自己实现的，大多是调用其他的压缩引擎。目前压缩引擎种类比较多，不同的压缩引擎有不同特点，如一些对图像压缩效果好，一些对数据压缩效果好。而加壳软件选择压缩引擎有一个特点，在保证压缩比的条件下，压缩速度慢些关系不是太大，但解压速度一定要快，这样加了壳的EXE文件运行起来速度才不会受太大的影响
第四课 常见压缩壳与加密壳
加壳软件按照其加壳目的和作用，可分为两类：一是压缩（Packers），二是保护（Protectors）。压缩这类壳主要目的是减小程序体积，如ASPacK、UPX和PECompact等。另一类是保护程序，用上了各种反跟踪技术保护程序不被调试、脱壳等，其加壳后的体积大小不是其考虑的主要因素，如ASProtect、Armadillo、EXECryptor等。随着加壳技术的发展，这两类软件之间的界线越来越模糊，很多加壳软件除具有较强的压缩性能，同时也有了较强的保护性能。
1.常用压缩壳介绍   
1). ASPacK
2). UPX
3). PECompact
2.加密保护壳介绍
1). ASProtect
为了保护自己的软件不轻易被他人“借鉴”，有必要对软件进行一些加密保护，而这方面目前己有成熟的专业加密软件可选择。但不要太依赖壳的保护，大多数壳是可以被攻破的，还是在自身保护上下些功夫。加密软件比较多，但在强度与兼容性上做的好的并不多，这里向大家介绍几款常见的。

　现在壳的发展一个趋势就是虚拟机保护，利用虚拟机保护后，能大大提高强度，因此建议尽可能使用此类技术保护软件。如Themida ，WinLicense，EXECryptor等壳带有虚拟机保护功能，因此得用好其SDK。
1). ASProtect
2). Armadillo加密壳
3). EXECryptor加密壳
4). Themida加密壳
5). VMProtect

第五课 文件类型分析
拿到一个壳，第一步就是用相关工具分析一下是什么壳，然后就可心中有数地跟踪分析。文件分析工具有PEID，FileInfo等。
1.PEiD
 PEiD的GUI界面操作非常方便直观。它的原理是利用查特征串搜索来完成识别工作的。各种开发语言都有固定的启动代码部分，利用这点就可识别出是何种语言编编译的
 有些外壳程序为了欺骗PEiD等文件识别软件，会伪造启动代码部分，例如将入口代码改成与Visual C++ 6.0所编程程序入口处类似代码，即可达到欺骗目的。所以，文件识别工具所给出的结果只是个参考，文件是否被加壳处理过，还得跟踪分析程序代码才可得知。
   PEiD分析不出类型的文件就报告是“Nothing found *”，如出现这情况一般都是未知壳或新版的壳。
2.FileInfo

第六课 寻找OEP
一般的压缩壳，如Aspack等都有专用的脱壳机 。而加密壳（如ASProtect,Armadillo） 一般很少有脱壳机，必须手工脱壳。手工脱壳一般情况是分三步：一是查找程序的真正入口点（OEP）；二是抓取内存映像文件；三是输入表重建。（当然现在的加密壳复杂些，要考虑更多的东西）
OEP是Original Entry Point缩写，即程序加壳前的真正的入口点。
外壳初始化的现场环境（各寄存器值）与原程序的现场环境是相同的。加壳程序初始化时保存各寄存器的值，外壳执行完毕，会恢复各寄存器内容。其代码形式一般如下：

PUSHFD ; 将标志寄存器入栈保存
PUSHAD ; push eax, ecx, edx, ebx, esp, ebp, esi, edi
…… ; 外壳代码部分
POPAD ; pop edi, esi, ebp, esp, ebx, edx, ecx, eax
POPFD ; 恢复标志寄存器
JMP OEP ;
OEP: …… ; 解压后的程序原代码

1.根据跨段指令寻找OEP
绝大多数加壳程序在被加密的程序中加上一个或多个段，所以依据跨段的转移指令（JMP）就可找到真正的入口点，此时就会有POPAD/POPFD指令出现。UPX 用了一次跨段的转移指令（JMP），在跳到OEP处会看到虚拟地址的值有一个突变，此时就能确定OEP了。
2.根据堆栈平衡原理找OEP
操作方法：多数壳在运行到OEP的时候ESP=0012FFC4，这就是说程序的第一句是对0012FFC0进行写入操作，只要在0012FFC0下硬件写入断点（命令行里键入HW 12FFC0），我们就能停在OEP的第二句处。
注意：并不是所有程序加载时，ESP的值是0012FFC4，这个值是什么由操作系统决定，将SizeOfStackCOmmit改大ESP就会变，这是因为操作系统从这个页向上找一个足够大地方当作stack了（感谢forgot解释）。你只要记住你系统加载时的ESP值，对其设断即可。

3.根据编译语言特点找OEP

各类语言编译的文件入口点都有一些规律，可以这利用这点来寻找入口点。
1）Delphi程序
执行程序，用LordPE（或Prodump）选dump(full)脱壳，存为dump.exe。接着用Hex Workshop打开dump.exe，搜索文本“runtime”，搜到后，向前查找离“runtime”最近的十六进制数字“55 8B EC”，数字所在的地址就是程序的OEP。
2）Visual C程序
可以利用Visual C启动部分的几个函数GetCommandLineA(W)、GetVersion、GetModuleHandleA(W)、GetStartupInfoA(W) 等来定位程序的OEP。

常见的各类编译语言的入口汇编代码都要熟悉，因为一些加密强壳会偷OEP处的代码到壳里，一般情况各编译语言入口代码都相同，到时只需要直接引用相关程序的入口代码，这给我们恢复代码带来方便。
4.用内存断点找OEP
什么是二次内存断点，三次内存断点。还有很多人对内存断点的原理不是很明白。其实只要懂得壳是如何解压代码的，那么就完全可以按自己的喜欢来下断。
***************************************************************************

第七课 Dump内存映像
第八课 重建输入表
第九课 手动确定IAT的地址与大小
...
第十二课 ASProtect 2.x壳