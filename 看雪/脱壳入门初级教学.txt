脱壳入门初级教学（看完后对脱壳过程有个简单的了解）
学习的地址：https://bbs.pediy.com/thread-20366.htm
第一课 PE格式
PE格式，PE是Portable Executable File Format（可移植的执行体）简写，它是目前Windows平台上的主流可执行文件格式。

第二课 SEH技术
结构化异常处理（Structured Exception Handling，SEH）是Windows操作系统处理程序错误或异常的技术。SEH是Windows操作系统的一种系统机制，与特定的程序设计语言无关。
第三课 认识壳
1. 什么是壳？
在一些计算机软件里也有一段专门负责
 保护软件不被非法修改或反编译的程序  
。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，就把这样的程序称为“壳”了。
 壳和病毒在某些方面比较类似，都需要比原程序代码更早的获得控制权。壳修改了原程序的执行文件的组织结构，从而能够比原程序的代码提前获得控制权，并且不会影响原程序的正常运行。
 加壳过的EXE文件是可执行文件，它可以同正常的EXE文件一样执行。用户执行的实际上是外壳程序，这个外壳程序负责把用户原来的程序在内存中解压缩，并把控制权交还给解开后的真正程序，这一切工作都是在内存中运行的，整个过程对用户是透明的。
 1）获取壳自己所需要使用的API地址
   如果用PE编辑工具查看加壳后的文件，会发现未加壳的文件和加壳后的文件的输入表不一样，加壳后的输入表一般所引入的DLL和API函数很少，甚至只有Kernel32.dll以及GetProcAddress这个API函数。壳实际上还需要其他的API函数来完成它的工作，为了隐藏这些API，它一般只在壳的代码中用显式链接方式动态加载这些API函数:3个脱壳相关的重要函数介绍
 2）解密原程序的各个区块(Section)的数据
   壳出于保护原程序代码和数据的目的，一般都会加密原程序文件的各个区块。在程序执行时外壳将会对这些区块数据解密，以让程序能正常运行。 壳一般按区块加密的，那么在解密时也按区块解密，并且把解密的区块数据按照区块的定义放在合适的内存位置。
   如果加壳时用到了压缩技术，那么在解密之前还有一道工序，当然是解压缩。这也是一些壳的特色之一，比如说原来的程序文件未加壳时1～2M大小，加壳后反而只有几百K。
   3）重定位
   文件执行时将被映像到指定内存地址中，这个初始内存地址称为基地址（ImageBase）
     对于EXE的程序文件来说，Windows系统会尽量满足。例如某EXE文件的基地址为0x400000，而运行时Windows系统提供给程序的基地址也同样是0x400000。在这种情况下就不需要进行地址“重定位”了。由于不需要对EXE文件进行“重定位”，所以加壳软件把原程序文件中用于保存重定位信息的区块干脆也删除了，这样使得加壳后的文件更加小巧。有些工具提供“Wipe Reloc”的功能，其实就是这个作用。
      不过对于DLL的动态链接库文件来说，Windows系统没有办法保证每一次DLL运行时提供相同的基地址。这样“重定位”就很重要了，此时壳中也需要提供进行“重定位”的代码，否则原程序中的代码是无法正常运行起来的。从这点来说，加壳的DLL比加壳的EXE更难修正。
 4）HOOK-API
 程序文件中的输入表的作用是让Windows系统在程序运行时提供API的实际地址给程序使用。在程序的第一行代码执行之前，Windows系统就完成了这个工作。
   壳一般都修改了原程序文件的输入表，然后自己模仿Windows系统的工作来填充输入表中相关的数据。在填充过程中，外壳就可填充HOOK-API的代码的地址，这样就可间接地获得程序的控制权。
5）跳转到程序原入口点（OEP）
    从这个时候起壳就把控制权交还给原程序了，一般的壳在这里会有明显的一个“分界线”。
3. 压缩引擎   
    各类加壳软件，其压缩算法一般不是自己实现的，大多是调用其他的压缩引擎。目前压缩引擎种类比较多，不同的压缩引擎有不同特点，如一些对图像压缩效果好，一些对数据压缩效果好。而加壳软件选择压缩引擎有一个特点，在保证压缩比的条件下，压缩速度慢些关系不是太大，但解压速度一定要快，这样加了壳的EXE文件运行起来速度才不会受太大的影响
第四课 常见压缩壳与加密壳
加壳软件按照其加壳目的和作用，可分为两类：一是压缩（Packers），二是保护（Protectors）。压缩这类壳主要目的是减小程序体积，如ASPacK、UPX和PECompact等。另一类是保护程序，用上了各种反跟踪技术保护程序不被调试、脱壳等，其加壳后的体积大小不是其考虑的主要因素，如ASProtect、Armadillo、EXECryptor等。随着加壳技术的发展，这两类软件之间的界线越来越模糊，很多加壳软件除具有较强的压缩性能，同时也有了较强的保护性能。
1.常用压缩壳介绍   
1). ASPacK
2). UPX
3). PECompact
2.加密保护壳介绍
1). ASProtect
为了保护自己的软件不轻易被他人“借鉴”，有必要对软件进行一些加密保护，而这方面目前己有成熟的专业加密软件可选择。但不要太依赖壳的保护，大多数壳是可以被攻破的，还是在自身保护上下些功夫。加密软件比较多，但在强度与兼容性上做的好的并不多，这里向大家介绍几款常见的。

　现在壳的发展一个趋势就是虚拟机保护，利用虚拟机保护后，能大大提高强度，因此建议尽可能使用此类技术保护软件。如Themida ，WinLicense，EXECryptor等壳带有虚拟机保护功能，因此得用好其SDK。
1). ASProtect
2). Armadillo加密壳
3). EXECryptor加密壳
4). Themida加密壳
5). VMProtect

第五课 文件类型分析
拿到一个壳，第一步就是用相关工具分析一下是什么壳，然后就可心中有数地跟踪分析。文件分析工具有PEID，FileInfo等。
1.PEiD
 PEiD的GUI界面操作非常方便直观。它的原理是利用查特征串搜索来完成识别工作的。各种开发语言都有固定的启动代码部分，利用这点就可识别出是何种语言编编译的
 有些外壳程序为了欺骗PEiD等文件识别软件，会伪造启动代码部分，例如将入口代码改成与Visual C++ 6.0所编程程序入口处类似代码，即可达到欺骗目的。所以，文件识别工具所给出的结果只是个参考，文件是否被加壳处理过，还得跟踪分析程序代码才可得知。
   PEiD分析不出类型的文件就报告是“Nothing found *”，如出现这情况一般都是未知壳或新版的壳。
2.FileInfo

第六课 寻找OEP
一般的压缩壳，如Aspack等都有专用的脱壳机 。而加密壳（如ASProtect,Armadillo） 一般很少有脱壳机，必须手工脱壳。手工脱壳一般情况是分三步：一是查找程序的真正入口点（OEP）；二是抓取内存映像文件；三是输入表重建。（当然现在的加密壳复杂些，要考虑更多的东西）
OEP是Original Entry Point缩写，即程序加壳前的真正的入口点。
外壳初始化的现场环境（各寄存器值）与原程序的现场环境是相同的。加壳程序初始化时保存各寄存器的值，外壳执行完毕，会恢复各寄存器内容。其代码形式一般如下：

PUSHFD ; 将标志寄存器入栈保存
PUSHAD ; push eax, ecx, edx, ebx, esp, ebp, esi, edi
…… ; 外壳代码部分
POPAD ; pop edi, esi, ebp, esp, ebx, edx, ecx, eax
POPFD ; 恢复标志寄存器
JMP OEP ;
OEP: …… ; 解压后的程序原代码

1.根据跨段指令寻找OEP
绝大多数加壳程序在被加密的程序中加上一个或多个段，所以依据跨段的转移指令（JMP）就可找到真正的入口点，此时就会有POPAD/POPFD指令出现。UPX 用了一次跨段的转移指令（JMP），在跳到OEP处会看到虚拟地址的值有一个突变，此时就能确定OEP了。
2.根据堆栈平衡原理找OEP
操作方法：多数壳在运行到OEP的时候ESP=0012FFC4，这就是说程序的第一句是对0012FFC0进行写入操作，只要在0012FFC0下硬件写入断点（命令行里键入HW 12FFC0），我们就能停在OEP的第二句处。
注意：并不是所有程序加载时，ESP的值是0012FFC4，这个值是什么由操作系统决定，将SizeOfStackCOmmit改大ESP就会变，这是因为操作系统从这个页向上找一个足够大地方当作stack了（感谢forgot解释）。你只要记住你系统加载时的ESP值，对其设断即可。

3.根据编译语言特点找OEP

各类语言编译的文件入口点都有一些规律，可以这利用这点来寻找入口点。
1）Delphi程序
执行程序，用LordPE（或Prodump）选dump(full)脱壳，存为dump.exe。接着用Hex Workshop打开dump.exe，搜索文本“runtime”，搜到后，向前查找离“runtime”最近的十六进制数字“55 8B EC”，数字所在的地址就是程序的OEP。
2）Visual C程序
可以利用Visual C启动部分的几个函数GetCommandLineA(W)、GetVersion、GetModuleHandleA(W)、GetStartupInfoA(W) 等来定位程序的OEP。

常见的各类编译语言的入口汇编代码都要熟悉，因为一些加密强壳会偷OEP处的代码到壳里，一般情况各编译语言入口代码都相同，到时只需要直接引用相关程序的入口代码，这给我们恢复代码带来方便。
4.用内存断点找OEP
什么是二次内存断点，三次内存断点。还有很多人对内存断点的原理不是很明白。其实只要懂得壳是如何解压代码的，那么就完全可以按自己的喜欢来下断。
2.内存断点寻找OEP的原理
  i.首先，在OD中内存断点，硬件断点和普通断点（F2下断）是有本质区别的。硬件断点等效与SoftICE命令bpm，他的中断要用到DR0-DR7的调试寄存器，也就是说OD通过这些DR0-DR7的调试寄存器来判断是否断下。
    普通断点（F2下断）等效于bpx，他是在所执行的的代码的当前地址的一个字节修改为CC（int3）。当程序运行到int3的时候就会产生一个异常，而这个异常将交给OD处理，把这个异常的regEIP-1以后就正好停在了需要的中断的地方（这个根据系统不同会不一样），同时OD在把上面的int3修改回原来的代码。
  而内存断点基本上使用的是对代码使用的保护属性来实现中断。
   所以我们不难得出下面的结论：
  1.内存写入中断的地方，一定是也可以用内存访问中断。
  2.内存执行的地方，也可以用内存访问中断。
   ii.如何使用内存断点来寻找OEP呢？
  要回答这个问题首先要回答这一个问题：壳是如何解压代码的？
  正如我们知道的，壳如果要把原来加密或压缩的代码运行起来就必须要解压和解密原来的代码。而这一个过程我们难道不能将他看做是对代码段（code段）的写入吗？好了，解压完毕了。我们要从壳代码的区段JMP到原来的代码段的时候，难道不正是对代码段（code段）的执行吗？
  理清了上面的关系就好办了，那么如果载入OD后，我们直接对code段下内存访问断点的时候，一定会中断在壳对code段的写入的代码的上面，就像上面的004AE247的这一行。而如果当他把code段的代码全部解压解密完毕了以后，JMP到OEP的时候，我们是不是还可以停在OEP的代码上面呢？而且每按下F9都会中断，因为这时code段在执行中哦！
  	而如果你还要继续问我为什么一定要到那个地方才可以下断呢？我难道不可以一开始就下断吗？
  正入我上面所说的，如果你在前面下断很可能壳对code段还没解压完毕呢，这时如果你不停的按F9，你将会看到OD的下方不断的在提示你“对401000写入中断” “对401002写入中断”“对401004写入中断”.......如果你不介意按F9到他把正个code段写完的话，我除了同情你的“F9”以外，没什么其他的意见！
  
  那么我们就没有别更快一点的办法了吗？
  有的！那就是我们呼之欲出的两次内存断点办法。
  怎么理解两次内存断点呢？
   让我来做一个假设吧，假设我是一个壳的作者。一个EXE文件的有code段，data段，rsrc段.....依次排列在你的内存空间中，那么我会怎么解码呢？呵呵~我比较笨一点，我会先将code段解码，然后再将data段解压，接着是rsrc段......那么聪明的你不难发现，只要你在data断或者rsrc段下内存访问断点，那么中断的时候code段就已经解压完毕了。这时我们再对code段下内存反问断点，不就可以到达OEP了吗？

  这里注意上面虽然下了两次内存访问断点，但是本质是不一样的，目的也是不一样的。

  1.对data段下内存访问断点而中断是因为内存写入中断，目的是断在对对data段的解压时，这时壳要对data段写数据，但是code段已经解压完毕。
  2.对code段下内存访问断点而中断是因为内存执行中断，目的当然就是寻找OEP了。
  总结一下：如果我们知道壳在什么地方对code段解压完毕我们就可以使用内存断点，找到OEP。如果不知道，那么我们就依靠2次内存断点去找，如果还不行就用多次内存断点。总之明白了原理在多次的内存断点其实都一样。从这个过程中我们了解的是壳在对区段解码的顺序！
  code段的第一次“执行”中断，所以这就是OEP了。
  总结一下：当我们在寻找OEP的时候，要多次对code下断“赌”一“赌”他解压完毕，如果不是就对别的段试试~如果程序跑飞了，那就没办法了，重来呗~其实说起来要赌的是：当data段，idata段，rsrc段摆在你的面前，你会好好“珍惜”那个段，不过还好上天还会给我们从来一次的机会（ctrl+F2 ^_^），那么我们会对那个不会跑飞的段说3个字----“先断你”如果非要在上面加一个次数，我希望是“一次内存断点就好了”
   是不是什么壳都可以用内存中断啊？
  不是每个都可以的，一些像UPX和ASPACK就不行。对于一些在OEP处有stolen code的代码也不行。
  也就是说当一个壳如果他在JMP 到OEP前的一行代码仍在都在对code段解压，那么我们就不能再使用这种办法了！
  或者说我们没必要使用内存断点更贴切一点！
第七课 Dump内存映像
***************************************************************************
外壳程序解压还原后就会跳到OEP处执行，此时内存映像文件是己解压的程序。这时就可抓取内存映像文件了（该过程称为Dump）。当然不一定非要在程序原入口点抓取，只要能保证内存映像文件是己还原的就行了。
工具：LordPE.EXE
将内存抓取的文件另存为dumped.exe，此时程序还不能运行，接下来就是重建输入表。
第八课 重建输入表
在脱壳中输入表处理是很关键的一个环节，因此要求脱壳者对PE格式中的输入表概念非常清楚。在磁盘文件中，PE文件的输入表结构如下图所示：
 PE文件运行时，Windows系统加载器首先搜索OriginalFirstThunk，如果存在，装载程序迭代搜索数组中的每个指针，找到每个IMAGE_IMPORT_BY_NAME结构所指向的输入函数的地址，然后用函数入口地址来替代由FirstThunk指向的 IMAGE_THUNK_DATA 数组里的元素值（即用真实的函数地址填充到IAT里）。因当PE文件装载内存后准备执行时，上图己转换成这种情况了：
第九课 手动确定IAT的地址与大小
   在第八课中讲到，点击ImportREC的“IAT AutoSearch”按钮，一般情况下ImportREC可以自动识别出IAT地址与大小。但如果不能自动识别，就必须手动确定IAT地址与大小，然后将IAT的RVA与Size填进ImportREC，点击“Get Import”按钮就可得到输入表。
   IAT是一块连续排列的数据，因此在数据窗口向上翻屏，直到出现00数据，寻找IAT起始地址
   然后向下翻屏，寻找IAT结束地址
   为了直观些，你也可以这样让数据窗口直接显示这些API函数，以确定IAT是否正确，在数据窗口点击鼠标右键
   调整显示格式后的数据窗口：
   这样就直观了，IAT中每组数据指向一个API函数，各DLL之间是以000000分开的。
第十课 DLL文件脱壳
第十一课 优化与自校验去除
第十一课 Armadillo壳
第十二课 ASProtect 2.x壳